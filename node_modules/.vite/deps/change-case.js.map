{
  "version": 3,
  "sources": ["../../change-case/src/index.ts"],
  "sourcesContent": ["// Regexps involved with splitting words in various case formats.\nconst SPLIT_LOWER_UPPER_RE = /([\\p{Ll}\\d])(\\p{Lu})/gu;\nconst SPLIT_UPPER_UPPER_RE = /(\\p{Lu})([\\p{Lu}][\\p{Ll}])/gu;\n\n// Used to iterate over the initial split result and separate numbers.\nconst SPLIT_SEPARATE_NUMBER_RE = /(\\d)\\p{Ll}|(\\p{L})\\d/u;\n\n// Regexp involved with stripping non-word characters from the result.\nconst DEFAULT_STRIP_REGEXP = /[^\\p{L}\\d]+/giu;\n\n// The replacement value for splits.\nconst SPLIT_REPLACE_VALUE = \"$1\\0$2\";\n\n// The default characters to keep after transforming case.\nconst DEFAULT_PREFIX_SUFFIX_CHARACTERS = \"\";\n\n/**\n * Supported locale values. Use `false` to ignore locale.\n * Defaults to `undefined`, which uses the host environment.\n */\nexport type Locale = string[] | string | false | undefined;\n\n/**\n * Options used for converting strings to pascal/camel case.\n */\nexport interface PascalCaseOptions extends Options {\n  mergeAmbiguousCharacters?: boolean;\n}\n\n/**\n * Options used for converting strings to any case.\n */\nexport interface Options {\n  locale?: Locale;\n  split?: (value: string) => string[];\n  /** @deprecated Pass `split: splitSeparateNumbers` instead. */\n  separateNumbers?: boolean;\n  delimiter?: string;\n  prefixCharacters?: string;\n  suffixCharacters?: string;\n}\n\n/**\n * Split any cased input strings into an array of words.\n */\nexport function split(value: string) {\n  let result = value.trim();\n\n  result = result\n    .replace(SPLIT_LOWER_UPPER_RE, SPLIT_REPLACE_VALUE)\n    .replace(SPLIT_UPPER_UPPER_RE, SPLIT_REPLACE_VALUE);\n\n  result = result.replace(DEFAULT_STRIP_REGEXP, \"\\0\");\n\n  let start = 0;\n  let end = result.length;\n\n  // Trim the delimiter from around the output string.\n  while (result.charAt(start) === \"\\0\") start++;\n  if (start === end) return [];\n  while (result.charAt(end - 1) === \"\\0\") end--;\n\n  return result.slice(start, end).split(/\\0/g);\n}\n\n/**\n * Split the input string into an array of words, separating numbers.\n */\nexport function splitSeparateNumbers(value: string) {\n  const words = split(value);\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const match = SPLIT_SEPARATE_NUMBER_RE.exec(word);\n    if (match) {\n      const offset = match.index + (match[1] ?? match[2]).length;\n      words.splice(i, 1, word.slice(0, offset), word.slice(offset));\n    }\n  }\n  return words;\n}\n\n/**\n * Convert a string to space separated lower case (`foo bar`).\n */\nexport function noCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  return (\n    prefix +\n    words.map(lowerFactory(options?.locale)).join(options?.delimiter ?? \" \") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to camel case (`fooBar`).\n */\nexport function camelCase(input: string, options?: PascalCaseOptions) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  const transform = options?.mergeAmbiguousCharacters\n    ? capitalCaseTransformFactory(lower, upper)\n    : pascalCaseTransformFactory(lower, upper);\n  return (\n    prefix +\n    words\n      .map((word, index) => {\n        if (index === 0) return lower(word);\n        return transform(word, index);\n      })\n      .join(options?.delimiter ?? \"\") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to pascal case (`FooBar`).\n */\nexport function pascalCase(input: string, options?: PascalCaseOptions) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  const transform = options?.mergeAmbiguousCharacters\n    ? capitalCaseTransformFactory(lower, upper)\n    : pascalCaseTransformFactory(lower, upper);\n  return prefix + words.map(transform).join(options?.delimiter ?? \"\") + suffix;\n}\n\n/**\n * Convert a string to pascal snake case (`Foo_Bar`).\n */\nexport function pascalSnakeCase(input: string, options?: Options) {\n  return capitalCase(input, { delimiter: \"_\", ...options });\n}\n\n/**\n * Convert a string to capital case (`Foo Bar`).\n */\nexport function capitalCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  return (\n    prefix +\n    words\n      .map(capitalCaseTransformFactory(lower, upper))\n      .join(options?.delimiter ?? \" \") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to constant case (`FOO_BAR`).\n */\nexport function constantCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  return (\n    prefix +\n    words.map(upperFactory(options?.locale)).join(options?.delimiter ?? \"_\") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to dot case (`foo.bar`).\n */\nexport function dotCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \".\", ...options });\n}\n\n/**\n * Convert a string to kebab case (`foo-bar`).\n */\nexport function kebabCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \"-\", ...options });\n}\n\n/**\n * Convert a string to path case (`foo/bar`).\n */\nexport function pathCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \"/\", ...options });\n}\n\n/**\n * Convert a string to path case (`Foo bar`).\n */\nexport function sentenceCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  const transform = capitalCaseTransformFactory(lower, upper);\n  return (\n    prefix +\n    words\n      .map((word, index) => {\n        if (index === 0) return transform(word);\n        return lower(word);\n      })\n      .join(options?.delimiter ?? \" \") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to snake case (`foo_bar`).\n */\nexport function snakeCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \"_\", ...options });\n}\n\n/**\n * Convert a string to header case (`Foo-Bar`).\n */\nexport function trainCase(input: string, options?: Options) {\n  return capitalCase(input, { delimiter: \"-\", ...options });\n}\n\nfunction lowerFactory(locale: Locale): (input: string) => string {\n  return locale === false\n    ? (input: string) => input.toLowerCase()\n    : (input: string) => input.toLocaleLowerCase(locale);\n}\n\nfunction upperFactory(locale: Locale): (input: string) => string {\n  return locale === false\n    ? (input: string) => input.toUpperCase()\n    : (input: string) => input.toLocaleUpperCase(locale);\n}\n\nfunction capitalCaseTransformFactory(\n  lower: (input: string) => string,\n  upper: (input: string) => string,\n) {\n  return (word: string) => `${upper(word[0])}${lower(word.slice(1))}`;\n}\n\nfunction pascalCaseTransformFactory(\n  lower: (input: string) => string,\n  upper: (input: string) => string,\n) {\n  return (word: string, index: number) => {\n    const char0 = word[0];\n    const initial =\n      index > 0 && char0 >= \"0\" && char0 <= \"9\" ? \"_\" + char0 : upper(char0);\n    return initial + lower(word.slice(1));\n  };\n}\n\nfunction splitPrefixSuffix(\n  input: string,\n  options: Options = {},\n): [string, string[], string] {\n  const splitFn =\n    options.split ?? (options.separateNumbers ? splitSeparateNumbers : split);\n  const prefixCharacters =\n    options.prefixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;\n  const suffixCharacters =\n    options.suffixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;\n  let prefixIndex = 0;\n  let suffixIndex = input.length;\n\n  while (prefixIndex < input.length) {\n    const char = input.charAt(prefixIndex);\n    if (!prefixCharacters.includes(char)) break;\n    prefixIndex++;\n  }\n\n  while (suffixIndex > prefixIndex) {\n    const index = suffixIndex - 1;\n    const char = input.charAt(index);\n    if (!suffixCharacters.includes(char)) break;\n    suffixIndex = index;\n  }\n\n  return [\n    input.slice(0, prefixIndex),\n    splitFn(input.slice(prefixIndex, suffixIndex)),\n    input.slice(suffixIndex),\n  ];\n}\n"],
  "mappings": "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",
  "names": []
}
